<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Group-Project-Final-Presentation.utf8</title>
    <meta charset="utf-8" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">


class: inverse, center, middle

![](https://ispark.istanbul/wp-content/uploads/2020/05/ispark-kurumsal-kimlik-yanyana-logo33.jpg)




---

class: inverse, center, middle

# Table of Contents

* Our Mission
* Brief Information About Dataset
* Boxplot of Avg. monthly price for each type of `Park Type`
* Hourly Occupancy Rate
* Price Histogram
* Number of Parks According to Their Type
* Frequency of the Parks


---

class: inverse, center, middle

# Brief Information About Dataset

We have two tables in our dataset. First table contains informations about ISPARK park areas. Second table contains hourly percentage of occupancies of these park areas between 19 November 2020 and 2 December 2020. We have collected this data by using IBB OpenData API. You can also access this API from [here.](https://api.ibb.gov.tr/ispark/Park)

---


class: inverse, center, middle

# Our Mission

Understanding the relation between the park capacity and the other metric. Creating shiny app that recommends best suitable parking spots with given limits. You can check our app from [here.](https://alihan.shinyapps.io/ISPARK-Shiny/)

---

class: inverse, left, middle

# Park Type Summary Table

We can see the count, total capacity and avg. monthly price in below table.

We have 5 different park types. 

"ON ROAD" type park is the highest with number of the parks also with pricing. 

"OPEN OTOPARK" type is the highest with the total capacity.


```
## # A tibble: 5 x 6
## # Groups:   ParkTipi [5]
##   ParkTipi `Park Adeti` `Toplam Kapasit~ `Ortalama Kapat~ `Ortalama Ücret~
##   &lt;chr&gt;           &lt;int&gt;            &lt;int&gt;            &lt;dbl&gt;            &lt;dbl&gt;
## 1 YOL ÜSTÜ          349            14128             40.5            12.5 
## 2 AÇIK OT~          163            71394            438               8.99
## 3 KAPALI ~           53            23608            445.             11.8 
## 4 TAKSI P~           11              272             24.7             0   
## 5 MINIBÜS~            1              100            100               0   
## # ... with 1 more variable: `Ortalama Aylik Ucret` &lt;dbl&gt;
```


---

class: inverse, left, middle

# Boxplot of Avg. Monthly Price

Open Park has a lower mean of monthly price than 'Close Park' and 'Road Park'.
Close Park's monthly price has outliers. But despite those outliers, its monthly prices varies the least.

&lt;img src="Group-Project-Final-Presentation_files/figure-html/unnamed-chunk-2-1.png" width="50%" /&gt;

---

class: inverse, left, middle

# Free/ Paid Parking Areas

We have 196 free, 381 paid parks in Istanbul.

%52 of the free parks are On Road Type of park. %40.8 of the free parks are Open Parks.

&lt;img src="Group-Project-Final-Presentation_files/figure-html/ucretdurumu, figures-side-1.png" width="50%" /&gt;&lt;img src="Group-Project-Final-Presentation_files/figure-html/ucretdurumu, figures-side-2.png" width="50%" /&gt;

---
class: inverse, left, middle

# Occupancy Rates

In all park types, average parking occupancy rate during daytime (around 15:00) is less than nights.

We can say on week days occupancy is lower than weekend days.

&lt;img src="Group-Project-Final-Presentation_files/figure-html/hourday, figures-side-1.png" width="50%" /&gt;&lt;img src="Group-Project-Final-Presentation_files/figure-html/hourday, figures-side-2.png" width="50%" /&gt;

---

class: inverse, left, middle

# Frequency of the Parks by District

If we look at the frequencies of the parks Fatih district has the highest park number After Fatih, Besiktas and Sisli districts are amongst highest. 

Arnavutkoy and Sultangazi are almost equal and has the lowest frequency.

&lt;img src="Group-Project-Final-Presentation_files/figure-html/figures-side-1.png" width="50%" /&gt;


---

class: inverse, left, middle

# Shiny App: Park Finder

We wanted to create an app to find best park location suits user's selection, while giving information about that park.

**For map, inputs are: **

`Total Capacity` : Total capacity of the park

`Occupancy Rate` : Occupancy rate of the park

`District` : Park's location as district

**For plots, inputs are:**

`District` : Park's location as district

`Park Area Name` : Park's name
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
